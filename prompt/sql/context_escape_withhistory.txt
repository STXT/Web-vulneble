**Role**: Senior Penetration Testing Engineer  
**Objective**: Implement the critical SQL-injection exploitation step—**Context Escape**  

**Task Requirements**  
When user-supplied input is embedded in any of the following SQL contexts, adjust that input so the subsequent payload can **break out of the original SQL context** while keeping the final statement syntactically valid:

1. **Break the original syntactic structure**: Exit the constraints imposed on the input (e.g., quotes or parentheses).  
2. **Preserve valid SQL via comment truncation**: Insert comment delimiters so the modified query remains legal and executes successfully.

Pay special attention to these context types:

* **String literals** (enclosed in single `'` or double `"` quotes)  
* **Numeric values** (no quotes, used directly in expressions)  
* **Identifiers** (table/column names—enclosed in back-ticks `` ` `` or bare)  
* **Sub-queries** (nested statements inside parentheses)

**Allowed Operations** *(choose only from the list below—do **not** add logic such as `OR 1=1`, which changes behaviour beyond context escape)*  

◼ **Quote closure**: Inject a quote (`'`, `"`, `` ` ``) to terminate the original string/identifier early  
◼ **Parenthesis closure**: Inject `(` or `)` to close nested structures  
◼ **Comment truncation**: Use `#`, `-- `, or `/* … */` to comment-out trailing characters and avoid syntax errors  

---

### Input Format
```
User input: [original user data]  
Resulting SQL query in the database: [full SQL statement] 
Failed history: [comma-separated list of previous incorrect variants] 
```

### Output Format
1. Analysis:  
   - **Step 1 – Identify context and delimiter**  
   - **Step 2 – Review failed history: For every failed variant, briefly state why it remained syntactically invalid or failed to escape the context.
   - **Step 3 – Devise closure strategy and append a comment**, showing the intermediate results after each tweak.  
     If the input is concatenated directly into the query (i.e., not wrapped in any context), simply output the raw input.

2. Final Answer:  
   ◼ 1–3 lines, each containing a valid escaped variant. **Every variant must be correct.**

---

### Example  

**Input**  
```
User input: 380585678319  
Resulting SQL query in the database: UPDATE users SET pass ='pss' WHERE (name='380585678319')
Failed history: 380585678319'# , 380585678319'--
```  

**Output**  
1. Analysis:
   - Step 1 – Identify context and delimiter 
     The value 380585678319 appears in a single-quoted string within a parenthesised condition: 
         WHERE (name='[input]')
   - Step 2 – Review failed history
         1. 380585678319'#
            Problem: closes the quote but does not close the parenthesis, leaving the query unbalanced.
         2. 380585678319'--
            Problem: again missing the closing ), so the parser still sees an open parenthesis and throws a syntax error.
   - Step 2 – Closure strategy with comment 
     1. Close the original quote: 380585678319'  
     2. Close the parenthesis: 380585678319')
     3. Add a comment to discard anything that follows:
         With MySQL style → 380585678319')#
         With standard SQL style → 380585678319')-- 

2. Final Answer:  
380585678319')# 
380585678319')--

---
Additional Note:
Pay special attention to parentheses——() handling in SQL structures. Failing to properly close parentheses is a common cause of syntax errors during context escape.
---

**Input**  
User input: {user_input}  
Resulting SQL query in the database: {sql_query}  
Failed history: {history}

**Output**