from browser.login import check_login
from llm.prompt import load_prompt
from llm.client import get_ai_response
from llm.parse import parse_llm_output
from .utils import test_sql_payload, needs_context_escape, has_extra_behavior 

'''
todo：history中可以包含payload对应的sql语句（如果没有的话就写sql语句被过滤之类的意思）；
上下文逃逸后，传入payload和其对应的sql语句给判断是否有额外行为的函数，如果有的话，直接不用行为改变了，直接算成功了;上下文逃逸也是，先判断下是否需要逃逸，不需要的话直接赋值就行
'''

def run_llm_sql_attack(
    input_point,
    driver,
    client,
    parse_llm_output = parse_llm_output,
    args = None,
    check_login_func = check_login,
    prompt_dir="prompt/sql"
):
    """
    对单个输入点运行LLM攻击（带历史记录版本）
    """
    url = input_point['form']['url']
    input_name = input_point['input_name']
    form = input_point['form']
    trigger_value = input_point['trigger_value']
    sql_statements = input_point['sql_statements']
    
    if not sql_statements:
        return None
    
    base_sql = sql_statements[0]
    
    attack_result = {
        'input_point': input_point,
        'context_escape': {
            'success': False,
            'payload': None,
            'tested_payloads': []
        },
        'behavior_change': {
            'success': False,
            'payload': None,
            'tested_payloads': []
        }
    }

    # 获取prompt
    context_escape = load_prompt(f"{prompt_dir}/context_escape.txt")
    context_escape_withhistory = load_prompt(f"{prompt_dir}/context_escape_withhistory.txt")
    behavior_change = load_prompt(f"{prompt_dir}/behavior_change.txt")
    behavior_change_withhistory = load_prompt(f"{prompt_dir}/behavior_change_withhistory.txt")

    # ===== 第一阶段: 上下文逃逸 =====
    print(f"\n[Context Escape] Input: {input_name} on {url}")
    
    if not needs_context_escape(trigger_value, base_sql):
        print("  [SKIP] Context escape not needed for this input")
        attack_result['context_escape']['success'] = True
        attack_result['context_escape']['payload'] = trigger_value
        attack_result['context_escape']['sql_statement'] = base_sql
    else:
        # 上下文逃逸尝试参数
        ce_attempts = 0
        max_ce_attempts = 3
        ce_history = []  # 存储失败历史
        
        while ce_attempts < max_ce_attempts and not attack_result['context_escape']['success']:
            ce_attempts += 1
            print(f"  Attempt {ce_attempts}/{max_ce_attempts}")
            
            # 选择提示模板
            if not ce_history:  # 第一次尝试使用普通模板
                prompt_template = context_escape
                prompt = prompt_template.format(
                    user_input=trigger_value,
                    sql_query=base_sql
                )
            else:  # 后续尝试使用带历史记录的模板
                prompt_template = context_escape_withhistory
                history_str = "\n".join(ce_history)
                prompt = prompt_template.format(
                    user_input=trigger_value,
                    sql_query=base_sql,
                    history=history_str
                )
            
            # 获取LLM响应
            output = get_ai_response(client, prompt)
            escape_payloads = parse_llm_output(output)
            
            if not escape_payloads:
                print("  No payloads generated by LLM")
                continue
            
            print(f"  Generated {len(escape_payloads)} payloads")
            
            # 测试每个逃逸payload
            for payload in escape_payloads:
                # 可以避免一些不必要的输入进去
                if trigger_value not in payload:
                    continue
                # 测试payload
                matched_sqls = test_sql_payload(driver, url, form, input_name, payload, trigger_value, args)
                # 检查payload是否完整出现在SQL中
                payload_appeared = any(payload in sql for sql in matched_sqls)
                
                # 记录结果
                result = {
                    'payload': payload,
                    'matched_sqls': matched_sqls,
                    'success': payload_appeared
                }
                attack_result['context_escape']['tested_payloads'].append(result)
                
                if payload_appeared:
                    print(f"  [SUCCESS] Payload '{payload}' found in SQL logs {matched_sqls}!")
                    attack_result['context_escape']['success'] = True
                    attack_result['context_escape']['payload'] = payload
                    attack_result['context_escape']['sql_statement'] = matched_sqls[0]
                    break
                else:
                    print(f"  [FAIL] Payload '{payload}' not found in SQL logs {matched_sqls}")
                    # 记录失败历史
                    if matched_sqls:
                        # 如果有匹配的SQL语句，记录payload和SQL
                        history_entry = f"Payload: {payload} | SQL: {matched_sqls[0]}"  # 取第一条SQL作为示例
                    else:
                        # 如果没有匹配的SQL，说明SQL被过滤或未记录
                        history_entry = f"Payload: {payload} | SQL: filtered or not logged"
                    ce_history.append(history_entry)

        
    # 如果上下文逃逸失败，直接返回
    if not attack_result['context_escape']['success']:
        return attack_result


    # ===== 第二阶段: 行为改变 =====
    print(f"\n[Behavior Change] Using escaped payload: {attack_result['context_escape']['payload']}")
    escaped_payload = attack_result['context_escape']['payload']
    escaped_sql = attack_result['context_escape']['sql_statement']
    # +++ 新增检查：判断逃逸后的payload是否已有额外行为 +++
    if has_extra_behavior(escaped_sql, escaped_payload):
        print("  [SKIP] Behavior change already achieved by context escape payload")
        attack_result['behavior_change']['success'] = True
        attack_result['behavior_change']['payload'] = escaped_payload
        return attack_result
    else:
        # 行为改变尝试参数
        bc_attempts = 0
        max_bc_attempts = 3
        bc_history = []  # 存储失败历史
        
        while bc_attempts < max_bc_attempts and not attack_result['behavior_change']['success']:
            bc_attempts += 1
            print(f"  Attempt {bc_attempts}/{max_bc_attempts}")
            
            # 选择提示模板
            if not bc_history:  # 第一次尝试使用普通模板
                prompt_template = behavior_change
                prompt = prompt_template.format(
                    user_input=attack_result['context_escape']['payload'],
                    sql_query=attack_result['context_escape']['sql_statement']
                )
            else:  # 后续尝试使用带历史记录的模板
                prompt_template = behavior_change_withhistory
                history_str = "\n".join(bc_history)
                prompt = prompt_template.format(
                    user_input=attack_result['context_escape']['payload'],
                    sql_query=attack_result['context_escape']['sql_statement'],
                    history=history_str
                )
            
            # 获取LLM响应
            output = get_ai_response(client, prompt)
            behavior_payloads = parse_llm_output(output)
            
            if not behavior_payloads:
                print("  No payloads generated by LLM")
                continue
            
            print(f"  Generated {len(behavior_payloads)} payloads")
            
            # 测试每个行为改变payload
            for payload in behavior_payloads:
                # 可以避免一些不必要的输入进去
                if trigger_value not in payload:
                    continue
                # 测试payload
                matched_sqls = test_sql_payload(driver, url, form, input_name, payload, trigger_value, args)
                
                # 检查payload是否完整出现在SQL中
                payload_appeared = any(payload in sql for sql in matched_sqls)
                
                # 记录结果
                result = {
                    'payload': payload,
                    'matched_sqls': matched_sqls,
                    'success': payload_appeared
                }
                attack_result['behavior_change']['tested_payloads'].append(result)
                
                if payload_appeared:
                    print(f"  [SUCCESS] Payload '{payload}' found in SQL logs {matched_sqls}!")
                    attack_result['behavior_change']['success'] = True
                    attack_result['behavior_change']['payload'] = payload
                    break
                else:
                    print(f"  [FAIL] Payload '{payload}' not found in SQL logs {matched_sqls}")
                    # 记录失败历史
                    if matched_sqls:
                        # 如果有匹配的SQL语句，记录payload和SQL
                        history_entry = f"Payload: {payload} | SQL: {matched_sqls[0]}"  # 取第一条SQL作为示例
                    else:
                        # 如果没有匹配的SQL，说明SQL被过滤或未记录
                        history_entry = f"Payload: {payload} | SQL: filtered or not logged"
                    bc_history.append(history_entry)
    
    return attack_result